# Loop through file
while read item; do
  echo "$item"
done <file.list


# Handy basename alternative
find /path/to/files -type f | grep bin | sed 's!.*/!!'

# focused search
fzf | xargs cat | grep assert | less
#(type testlib)

# Increment template log statements:
FN=get_network_info.sh
for i in $(seq 1 100); do
  sed -i "0,/0000/ s/0000/$i/g" $FN # 0, substitutes the first match only
  grep -q "echo '0000'" $FN || break
done


# arrays
dirs[0] = '/'
dirs[1] = '/home'

# find/exec on mac
find . -type f -exec wc -l {} \;

# sort files by number of lines
wc -l classes.output/* | sort -n
find classes.output -type f -exec wc -l {} \; | sort -rn | less

# is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# absolute filepath of parent dir:
"$(cd ..; pwd)"

# check shell type
"[[ $- == *i* ]] && echo 'Interactive' || echo 'Not interactive'"
"shopt -q login_shell && echo 'Login shell' || echo 'Not login shell'"

# mass search/replace
find /path/to/dir/ -type f | xargs sed -i  's/replace_me_with/this/g'

# greater than
if [ "$a" -gt "$b" ];
fi

# remove a char from a string:
asdf="\"static\""
"${asdf//\"}"
# "static" vs. static

date +"%Y-%m-%d_%H-%M-%S"

# string include
if [[ $state == *"original"* ]]

# follow link
readlink -f /root/Public/myothertextfile.txt

# lazy variabel heredoc
VAR=$(cat <<'END_HEREDOC'
abc'asdf"
$(dont-execute-this)
foo"bar"''
END_HEREDOC
)

# default values in bash ksh?
COMMIT1=$1
COMMIT1=${COMMIT1:=f4c11a2}

# unset variable
end -U NAME
unset NAME

# check regex
[[ "$string" =~ ^[0-9]+$ ]] && echo yes

# filenames in batches, plus gsub:
names=$(ls packages/*.rpm | xargs -I % basename %)
names=${PACKAGE_NAMES//\.rpm/}

echo $(basename $(pwd)) # name directory were running in:
echo $(basename $(dirname $(<script_filepath>))) # equivalent to above
echo $(basename $(dirname $(pwd))) # name of 2 dirs up!

# args
for arg in $@;
do
  [ "vecap" = "$arg" ] && echo hello
done

## increment/math
var=0
echo $((var++))
echo $((var++))
echo $((COLUMNS - 2))
echo $((RANDOM % 2)) # random 1 or 0

## no escape
port=$(cat file | grep -o "$pattern")     # works
port="$(cat file | grep -o \"$pattern\")" # can't work

(list)   # run in subshell, exit 1 does not kill the script
{list; } # run in current shell

for i in $(seq 1 $END); do echo $i; done
for i in /etc/*.conf; do cp $i /backup; done
for word in word1 word2 word3 word4; do echo word; done

Ex.
for i in $(vagrant box list | cut -f 1 -d' ' | xargs); do vagrant box remove $i; done

# run a function in the background
my_background_method {
  ...
}
my_background_method &


case "$asdf" in
"hello")
   echo hello
   ;;
"abcd")
   echo asdf
   ;;
esac


# Background watcher
ls /path/to/file || exit
:>/root/log
:>/root/err
run_when_appears() {
  for i in $(seq 1 30); do
    ls /path/to/generated_file && break
    echo "waiting..." >> /root/log;
    sleep 20
  done
  run_thing
}
run_when_appears &

