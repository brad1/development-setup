# file access times!
ls -l --time=atime


# printf justifications:
# # although this is C, bash printf accepts same options.
printf ("<%d> is not justified.\n", x);
printf ("<%5d> is right-justified.\n", x);
printf ("<%-5d> The minus sign makes it left-justified.\n", x);
/* Demonstrate with strings. */
printf ("'%s' is not justified.\n", y);
printf ("'%10s' is right-justified.\n", y);
printf ("'%-10s' is left-justified using a minus sign.\n", y);

# detect interactive shell
if [ -t 1 ] ; then echo terminal; else echo "not a terminal"; fi

# ssh w/ expon. backoff until succeeds
for i in $(seq 1 60) ; do
  ssh -p5147 gear@192.168.1.2 && break
  echo waiting: $((i * i))
  sleep $((i * i))
done

# subshells!
pstree -pls $$

# for all tmux, and not just your stack:
ps aux | grep -v grep | grep tmux | tail -n1 | awk '{print $2}'
9103
pstree -pls 9103
systemd(1)───tmux: server(9103)─┬─zsh(9104)───vim(12998)
                                ├─zsh(9375)
                                ├─zsh(9609)
                                ├─zsh(9763)
                                ├─zsh(10182)
                                └─zsh(11843)───ranger(11789)───zsh(11804)───pstree(24498)

# Scraping the last bit of some command output:
vagrant ssh --command ... | xargs | awk '{print $NF}'

# Am I in a subshell?  this doesn't work with zsh
#$ ( if [ "$$" -eq "$BASHPID" ]; then echo not subshell; else echo subshell; fi )
#subshell
#$   if [ "$$" -eq "$BASHPID" ]; then echo not subshell; else echo subshell; fi
#not subshell
#
# kind of cheating, but:
# echo $PPID # in a new shell session under tmux, expect a low number like 300.
# echo $PPID # in a new shell started from ranger, expect a large number in the thousands.  WOrks in zsh too!

# check if I am in a ranger subshell:
ps aux | grep "$PPID" | grep -qa ranger && echo "You are in ranger" || echo "not in ranger"
 not 100%, but should be OK in development.


# file timestamps
stat -c %y *
- or -
date -r "$1" +%s

# # # Misc # # #
#
cat msg.xml
<?xml version = "1.0" encoding = "UTF-8"?>
<alert xmlns = "urn:oasis:names:tc:emergency:cap:1.2">
  <identifier>test</identifier>
  <sent>2020-06-20T15:00:00-05:00</sent>
  <msgType>Alert</msgType>
  <info>
    <headline>matchme</headline>
  </info>
</alert>
msg="$(cat msg.xml)"
curl -XPOST --data "$msg" http://127.0.0.1/....
#
#


#  print current method name
${FUNCNAME[0]}

# line-by-line file multiple delimieters:
echo "12|23|11" | awk '{split($0,a,"|"); print a[3],a[2],a[1]}'

# awk delimeters
echo "1.2.4" | awk -F. '{print $1$2$3}'

# switch on find command
if [ -z $(find /var/log/crashes -name "app-*.log" ) ]
then
    echo "File is missing!"
fi

# glob evaluation
compgen -G "/tmp/someFiles*

# remote polling w/ pgrep
ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" user@$environment 'for i in $(seq 1 12); do (sleep 10; echo -n .; pgrep script.sh >/dev/null 2>&1 ) && break; done'
ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" user@$environment 'for i in $(seq 1 60); do (sleep 10; echo -n .; pgrep script.sh >/dev/null 2>&1 ) || break; done'
ssh -o StrictHostKeyChecking=no -p "$SSH_PORT" user@$environment '! pgrep script.sh >/dev/null 2>&1'

# one of my favorites
# recursive diff
find . -type f | xargs md5sum | awk '{print $2 " " $1}' | sort | awk '{print $2 " " $1 }'
# then compare a coupel files with vim -d
# a variant
find . -name post-\* | xargs md5sum | awk '{print $2 " " $1}' | sort | awk '{print $2 " " $1 }'


# find exec on fedora
find . -user root -exec rm -rf {} +

# find filenames
find vendor/ -type f | args -L1 -I{} basename {}
# stripping out version string from filename # | sort | sed -E 's/-[0-9]{1,2}.*//'

# nonempty files
find . -type f -name scratch -size +0

# greater less then
[ 0 -lt 1 ] && echo hello

# search replace
# #------------------------------------------------------------------------------
rw = {} # replace with

rw['pgsql-9\.6'] = 'pgsql-12'
rw['postgresql96'] = 'postgresql12'
rw['postgresql-9\.6'] = 'postgresql-12'
rw['pgdg96'] = 'pgdg12'


rw.each_pair do |p,s| # pattern, substitute
  `ag -l '#{p}' | xargs sed -i 's/#{p}/#{s}/g'`
end
# ------------------------------------------------------------------------------

# polling
# ------------------------------------------------------------------------------
server_is_using() {
  #shellcheck disable=2009
  ps aux | grep -v grep | grep -qs "$1"
}

while (server_is_using "kworker"); do
  sleep 20
  [ -z "$start" ] && start="$(date +%s)"
  now=$(date +%s)
  [ $((now-start)) -le 360 ] || break # timeout after 6 mins
done
# ------------------------------------------------------------------------------



# universal argument parser
while (( "$#" )); do
  case "$1" in
    -f|--flag-with-argument)
      FARG=$2
      shift 2
      ;;
    --) # end argument parsing
      shift
      break
      ;;
    -*|--*=) # unsupported flags
      echo "Error: Unsupported flag $1" >&2
      exit 1
      ;;
    *) # preserve positional arguments
      PARAMS="$PARAMS $1"
      shift
      ;;
  esac
done


# all args
echo "$@"

# short substitutions
state=off # or on!
state=${state//off/disabled}
state=${state//on/enabled}

# Loop through file
while read item; do
  echo "$item"
done <file.list


# Handy basename alternative
find /path/to/files -type f | grep bin | sed 's!.*/!!'

# focused search
fzf | xargs cat | grep assert | less
#(type testlib)

# Increment template log statements:
FN=get_network_info.sh
for i in $(seq 1 100); do
  sed -i "0,/0000/ s/0000/$i/g" $FN # 0, substitutes the first match only
  grep -q "echo '0000'" $FN || break
done
#
# poll for test breakage
for i in $(seq 1 12); do bundle exec rspec spec || break; done


# arrays
dirs[0] = '/'
dirs[1] = '/home'

# find/exec on mac
find . -type f -exec wc -l {} \;

# sort files by number of lines
wc -l classes.output/* | sort -n
find classes.output -type f -exec wc -l {} \; | sort -rn | less

# is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# absolute filepath of parent dir:
"$(cd ..; pwd)"

# check shell type
"[[ $- == *i* ]] && echo 'Interactive' || echo 'Not interactive'"
"shopt -q login_shell && echo 'Login shell' || echo 'Not login shell'"

# mass search/replace
find /path/to/dir/ -type f | xargs sed -i  's/replace_me_with/this/g'

# greater than
if [ "$a" -gt "$b" ];
fi

# remove a char from a string:
asdf="\"static\""
"${asdf//\"}"
# "static" vs. static

date +"%Y-%m-%d_%H-%M-%S"

# string include
if [[ $state == *"original"* ]]
# strign equality
if [ "$state" == "original" ]]

# follow link
readlink -f /root/Public/myothertextfile.txt

# lazy variabel heredoc
VAR=$(cat <<'END_HEREDOC'
abc'asdf"
$(dont-execute-this)
foo"bar"''
END_HEREDOC
)

# default values in bash ksh?
COMMIT1=$1
COMMIT1=${COMMIT1:=f4c11a2}

# unset variable
end -U NAME
unset NAME

# check regex
[[ "$string" =~ ^[0-9]+$ ]] && echo yes

# filenames in batches, plus gsub:
names=$(ls packages/*.rpm | xargs -I % basename %)
names=${PACKAGE_NAMES//\.rpm/}

echo $(basename $(pwd)) # name directory were running in:
echo $(basename $(dirname $(<script_filepath>))) # equivalent to above
echo $(basename $(dirname $(pwd))) # name of 2 dirs up!

# args
for arg in $@;
do
  [ "vecap" = "$arg" ] && echo hello
done

## increment/math
var=0
echo $((var++))
echo $((var++))
echo $((COLUMNS - 2))
echo $((RANDOM % 2)) # random 1 or 0

## no escape
port=$(cat file | grep -o "$pattern")     # works
port="$(cat file | grep -o \"$pattern\")" # can't work

(list)   # run in subshell, exit 1 does not kill the script
{list; } # run in current shell

for i in $(seq 1 $END); do echo $i; done
for i in /etc/*.conf; do cp $i /backup; done
for word in word1 word2 word3 word4; do echo word; done

Ex.
for i in $(vagrant box list | cut -f 1 -d' ' | xargs); do vagrant box remove $i; done

# run a function in the background
my_background_method {
  ...
}
my_background_method &


case "$asdf" in
"hello")
   echo hello
   ;;
"abcd")
   echo asdf
   ;;
esac


# Background watcher
ls /path/to/file || exit
:>/root/log
:>/root/err
run_when_appears() {
  for i in $(seq 1 30); do
    ls /path/to/generated_file && break
    echo "waiting..." >> /root/log;
    sleep 20
  done
  run_thing
}
run_when_appears &










# man [
    -b FILE - True if the FILE exists and is a block special file.
    -c FILE - True if the FILE exists and is a special character file.
    -d FILE - True if the FILE exists and is a directory.
    -e FILE - True if the FILE exists and is a file, regardless of type (node, directory, socket, etc.).
    -f FILE - True if the FILE exists and is a regular file (not a directory or device).
    -G FILE - True if the FILE exists and has the same group as the user running the command.
    -h FILE - True if the FILE exists and is a symbolic link.
    -g FILE - True if the FILE exists and has set-group-id (sgid) flag set.
    -k FILE - True if the FILE exists and has a sticky bit flag set.
    -L FILE - True if the FILE exists and is a symbolic link.
    -O FILE - True if the FILE exists and is owned by the user running the command.
    -p FILE - True if the FILE exists and is a pipe.
    -r FILE - True if the FILE exists and is readable.
    -S FILE - True if the FILE exists and is socket.
    -s FILE - True if the FILE exists and has nonzero size.
    -u FILE - True if the exists and set-user-id (suid) flag is set.
    -w FILE - True if the FILE exists and is writable.
    -x FILE - True if the FILE exists and is executable.
